//
//
//Copyright 2018 Continusec Pty Ltd
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: sso.proto

package geecert

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ResponseCode int32

const (
	ResponseCode_OK               ResponseCode = 0
	ResponseCode_INVALID_ID_TOKEN ResponseCode = 1
	ResponseCode_NO_CERTS_ALLOWED ResponseCode = 2
)

// Enum value maps for ResponseCode.
var (
	ResponseCode_name = map[int32]string{
		0: "OK",
		1: "INVALID_ID_TOKEN",
		2: "NO_CERTS_ALLOWED",
	}
	ResponseCode_value = map[string]int32{
		"OK":               0,
		"INVALID_ID_TOKEN": 1,
		"NO_CERTS_ALLOWED": 2,
	}
)

func (x ResponseCode) Enum() *ResponseCode {
	p := new(ResponseCode)
	*p = x
	return p
}

func (x ResponseCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResponseCode) Descriptor() protoreflect.EnumDescriptor {
	return file_sso_proto_enumTypes[0].Descriptor()
}

func (ResponseCode) Type() protoreflect.EnumType {
	return &file_sso_proto_enumTypes[0]
}

func (x ResponseCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResponseCode.Descriptor instead.
func (ResponseCode) EnumDescriptor() ([]byte, []int) {
	return file_sso_proto_rawDescGZIP(), []int{0}
}

type SSHCertsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IdToken       string                 `protobuf:"bytes,1,opt,name=id_token,json=idToken,proto3" json:"id_token,omitempty"`
	PublicKey     string                 `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSHCertsRequest) Reset() {
	*x = SSHCertsRequest{}
	mi := &file_sso_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSHCertsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSHCertsRequest) ProtoMessage() {}

func (x *SSHCertsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_sso_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSHCertsRequest.ProtoReflect.Descriptor instead.
func (*SSHCertsRequest) Descriptor() ([]byte, []int) {
	return file_sso_proto_rawDescGZIP(), []int{0}
}

func (x *SSHCertsRequest) GetIdToken() string {
	if x != nil {
		return x.IdToken
	}
	return ""
}

func (x *SSHCertsRequest) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

type SSHCertsResponse struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	Status                 ResponseCode           `protobuf:"varint,1,opt,name=status,proto3,enum=ResponseCode" json:"status,omitempty"`
	Certificate            string                 `protobuf:"bytes,2,opt,name=certificate,proto3" json:"certificate,omitempty"`
	CertificateAuthorities []string               `protobuf:"bytes,3,rep,name=certificate_authorities,json=certificateAuthorities,proto3" json:"certificate_authorities,omitempty"`
	Config                 []string               `protobuf:"bytes,4,rep,name=config,proto3" json:"config,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *SSHCertsResponse) Reset() {
	*x = SSHCertsResponse{}
	mi := &file_sso_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSHCertsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSHCertsResponse) ProtoMessage() {}

func (x *SSHCertsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_sso_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSHCertsResponse.ProtoReflect.Descriptor instead.
func (*SSHCertsResponse) Descriptor() ([]byte, []int) {
	return file_sso_proto_rawDescGZIP(), []int{1}
}

func (x *SSHCertsResponse) GetStatus() ResponseCode {
	if x != nil {
		return x.Status
	}
	return ResponseCode_OK
}

func (x *SSHCertsResponse) GetCertificate() string {
	if x != nil {
		return x.Certificate
	}
	return ""
}

func (x *SSHCertsResponse) GetCertificateAuthorities() []string {
	if x != nil {
		return x.CertificateAuthorities
	}
	return nil
}

func (x *SSHCertsResponse) GetConfig() []string {
	if x != nil {
		return x.Config
	}
	return nil
}

type ServerConfig struct {
	state                       protoimpl.MessageState              `protogen:"open.v1"`
	CaKeyPath                   string                              `protobuf:"bytes,1,opt,name=ca_key_path,json=caKeyPath,proto3" json:"ca_key_path,omitempty"`
	GenerateCertDurationSeconds int32                               `protobuf:"varint,2,opt,name=generate_cert_duration_seconds,json=generateCertDurationSeconds,proto3" json:"generate_cert_duration_seconds,omitempty"`
	AllowedUsers                map[string]*ServerConfig_UserConfig `protobuf:"bytes,4,rep,name=allowed_users,json=allowedUsers,proto3" json:"allowed_users,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ListenPort                  int32                               `protobuf:"varint,5,opt,name=listen_port,json=listenPort,proto3" json:"listen_port,omitempty"`
	AllowedDomainForIdToken     string                              `protobuf:"bytes,6,opt,name=allowed_domain_for_id_token,json=allowedDomainForIdToken,proto3" json:"allowed_domain_for_id_token,omitempty"`
	AllowedClientIdForIdToken   string                              `protobuf:"bytes,7,opt,name=allowed_client_id_for_id_token,json=allowedClientIdForIdToken,proto3" json:"allowed_client_id_for_id_token,omitempty"`
	ServerCertPath              string                              `protobuf:"bytes,8,opt,name=server_cert_path,json=serverCertPath,proto3" json:"server_cert_path,omitempty"`
	ServerKeyPath               string                              `protobuf:"bytes,9,opt,name=server_key_path,json=serverKeyPath,proto3" json:"server_key_path,omitempty"`
	CaComment                   string                              `protobuf:"bytes,11,opt,name=ca_comment,json=caComment,proto3" json:"ca_comment,omitempty"`
	HttpListenPort              int32                               `protobuf:"varint,12,opt,name=http_listen_port,json=httpListenPort,proto3" json:"http_listen_port,omitempty"` // actually listens https if host_signing_tls_path set
	AllowedHosts                []string                            `protobuf:"bytes,13,rep,name=allowed_hosts,json=allowedHosts,proto3" json:"allowed_hosts,omitempty"`
	SshConnectForPublickeyPort  int32                               `protobuf:"varint,15,opt,name=ssh_connect_for_publickey_port,json=sshConnectForPublickeyPort,proto3" json:"ssh_connect_for_publickey_port,omitempty"`
	UserProfiles                map[string]*ServerConfig_Profile    `protobuf:"bytes,16,rep,name=user_profiles,json=userProfiles,proto3" json:"user_profiles,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// path to pem with key, cert and intermediates
	HostSigningTlsPath string `protobuf:"bytes,17,opt,name=host_signing_tls_path,json=hostSigningTlsPath,proto3" json:"host_signing_tls_path,omitempty"`
	// e.g. https://accounts.google.com/.well-known/openid-configuration for Google
	// e.g. https://login.microsoftonline.com/<tenancy id>/.well-known/openid-configuration for Azure AD
	OidcConfigurationUrl string `protobuf:"bytes,18,opt,name=oidc_configuration_url,json=oidcConfigurationUrl,proto3" json:"oidc_configuration_url,omitempty"`
	// if set verify "appid" claim for client ID, INSTEAD OF "aud" claim - useful for Azure Access Token
	LookForAudienceInAppId bool `protobuf:"varint,19,opt,name=look_for_audience_in_app_id,json=lookForAudienceInAppId,proto3" json:"look_for_audience_in_app_id,omitempty"`
	// if set, check for suffix in email field instead of "hd" cliam. useful for Azure Access Token
	LookForHostedDomainInEmail bool `protobuf:"varint,20,opt,name=look_for_hosted_domain_in_email,json=lookForHostedDomainInEmail,proto3" json:"look_for_hosted_domain_in_email,omitempty"`
	// if set, don't require email_verified field. Useful for Azure Access token
	SkipEmailVerified bool `protobuf:"varint,21,opt,name=skip_email_verified,json=skipEmailVerified,proto3" json:"skip_email_verified,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ServerConfig) Reset() {
	*x = ServerConfig{}
	mi := &file_sso_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerConfig) ProtoMessage() {}

func (x *ServerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_sso_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerConfig.ProtoReflect.Descriptor instead.
func (*ServerConfig) Descriptor() ([]byte, []int) {
	return file_sso_proto_rawDescGZIP(), []int{2}
}

func (x *ServerConfig) GetCaKeyPath() string {
	if x != nil {
		return x.CaKeyPath
	}
	return ""
}

func (x *ServerConfig) GetGenerateCertDurationSeconds() int32 {
	if x != nil {
		return x.GenerateCertDurationSeconds
	}
	return 0
}

func (x *ServerConfig) GetAllowedUsers() map[string]*ServerConfig_UserConfig {
	if x != nil {
		return x.AllowedUsers
	}
	return nil
}

func (x *ServerConfig) GetListenPort() int32 {
	if x != nil {
		return x.ListenPort
	}
	return 0
}

func (x *ServerConfig) GetAllowedDomainForIdToken() string {
	if x != nil {
		return x.AllowedDomainForIdToken
	}
	return ""
}

func (x *ServerConfig) GetAllowedClientIdForIdToken() string {
	if x != nil {
		return x.AllowedClientIdForIdToken
	}
	return ""
}

func (x *ServerConfig) GetServerCertPath() string {
	if x != nil {
		return x.ServerCertPath
	}
	return ""
}

func (x *ServerConfig) GetServerKeyPath() string {
	if x != nil {
		return x.ServerKeyPath
	}
	return ""
}

func (x *ServerConfig) GetCaComment() string {
	if x != nil {
		return x.CaComment
	}
	return ""
}

func (x *ServerConfig) GetHttpListenPort() int32 {
	if x != nil {
		return x.HttpListenPort
	}
	return 0
}

func (x *ServerConfig) GetAllowedHosts() []string {
	if x != nil {
		return x.AllowedHosts
	}
	return nil
}

func (x *ServerConfig) GetSshConnectForPublickeyPort() int32 {
	if x != nil {
		return x.SshConnectForPublickeyPort
	}
	return 0
}

func (x *ServerConfig) GetUserProfiles() map[string]*ServerConfig_Profile {
	if x != nil {
		return x.UserProfiles
	}
	return nil
}

func (x *ServerConfig) GetHostSigningTlsPath() string {
	if x != nil {
		return x.HostSigningTlsPath
	}
	return ""
}

func (x *ServerConfig) GetOidcConfigurationUrl() string {
	if x != nil {
		return x.OidcConfigurationUrl
	}
	return ""
}

func (x *ServerConfig) GetLookForAudienceInAppId() bool {
	if x != nil {
		return x.LookForAudienceInAppId
	}
	return false
}

func (x *ServerConfig) GetLookForHostedDomainInEmail() bool {
	if x != nil {
		return x.LookForHostedDomainInEmail
	}
	return false
}

func (x *ServerConfig) GetSkipEmailVerified() bool {
	if x != nil {
		return x.SkipEmailVerified
	}
	return false
}

type ServerConfig_UserConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Profiles      []string               `protobuf:"bytes,4,rep,name=profiles,proto3" json:"profiles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerConfig_UserConfig) Reset() {
	*x = ServerConfig_UserConfig{}
	mi := &file_sso_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerConfig_UserConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerConfig_UserConfig) ProtoMessage() {}

func (x *ServerConfig_UserConfig) ProtoReflect() protoreflect.Message {
	mi := &file_sso_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerConfig_UserConfig.ProtoReflect.Descriptor instead.
func (*ServerConfig_UserConfig) Descriptor() ([]byte, []int) {
	return file_sso_proto_rawDescGZIP(), []int{2, 0}
}

func (x *ServerConfig_UserConfig) GetProfiles() []string {
	if x != nil {
		return x.Profiles
	}
	return nil
}

type ServerConfig_Profile struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Principals      []string               `protobuf:"bytes,1,rep,name=principals,proto3" json:"principals,omitempty"`
	CertPermissions map[string]string      `protobuf:"bytes,2,rep,name=cert_permissions,json=certPermissions,proto3" json:"cert_permissions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SshConfigLines  []string               `protobuf:"bytes,3,rep,name=ssh_config_lines,json=sshConfigLines,proto3" json:"ssh_config_lines,omitempty"`
	KnownHosts      []string               `protobuf:"bytes,4,rep,name=known_hosts,json=knownHosts,proto3" json:"known_hosts,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ServerConfig_Profile) Reset() {
	*x = ServerConfig_Profile{}
	mi := &file_sso_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerConfig_Profile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerConfig_Profile) ProtoMessage() {}

func (x *ServerConfig_Profile) ProtoReflect() protoreflect.Message {
	mi := &file_sso_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerConfig_Profile.ProtoReflect.Descriptor instead.
func (*ServerConfig_Profile) Descriptor() ([]byte, []int) {
	return file_sso_proto_rawDescGZIP(), []int{2, 1}
}

func (x *ServerConfig_Profile) GetPrincipals() []string {
	if x != nil {
		return x.Principals
	}
	return nil
}

func (x *ServerConfig_Profile) GetCertPermissions() map[string]string {
	if x != nil {
		return x.CertPermissions
	}
	return nil
}

func (x *ServerConfig_Profile) GetSshConfigLines() []string {
	if x != nil {
		return x.SshConfigLines
	}
	return nil
}

func (x *ServerConfig_Profile) GetKnownHosts() []string {
	if x != nil {
		return x.KnownHosts
	}
	return nil
}

var File_sso_proto protoreflect.FileDescriptor

const file_sso_proto_rawDesc = "" +
	"\n" +
	"\tsso.proto\"K\n" +
	"\x0fSSHCertsRequest\x12\x19\n" +
	"\bid_token\x18\x01 \x01(\tR\aidToken\x12\x1d\n" +
	"\n" +
	"public_key\x18\x02 \x01(\tR\tpublicKey\"\xac\x01\n" +
	"\x10SSHCertsResponse\x12%\n" +
	"\x06status\x18\x01 \x01(\x0e2\r.ResponseCodeR\x06status\x12 \n" +
	"\vcertificate\x18\x02 \x01(\tR\vcertificate\x127\n" +
	"\x17certificate_authorities\x18\x03 \x03(\tR\x16certificateAuthorities\x12\x16\n" +
	"\x06config\x18\x04 \x03(\tR\x06config\"\xaf\v\n" +
	"\fServerConfig\x12\x1e\n" +
	"\vca_key_path\x18\x01 \x01(\tR\tcaKeyPath\x12C\n" +
	"\x1egenerate_cert_duration_seconds\x18\x02 \x01(\x05R\x1bgenerateCertDurationSeconds\x12D\n" +
	"\rallowed_users\x18\x04 \x03(\v2\x1f.ServerConfig.AllowedUsersEntryR\fallowedUsers\x12\x1f\n" +
	"\vlisten_port\x18\x05 \x01(\x05R\n" +
	"listenPort\x12<\n" +
	"\x1ballowed_domain_for_id_token\x18\x06 \x01(\tR\x17allowedDomainForIdToken\x12A\n" +
	"\x1eallowed_client_id_for_id_token\x18\a \x01(\tR\x19allowedClientIdForIdToken\x12(\n" +
	"\x10server_cert_path\x18\b \x01(\tR\x0eserverCertPath\x12&\n" +
	"\x0fserver_key_path\x18\t \x01(\tR\rserverKeyPath\x12\x1d\n" +
	"\n" +
	"ca_comment\x18\v \x01(\tR\tcaComment\x12(\n" +
	"\x10http_listen_port\x18\f \x01(\x05R\x0ehttpListenPort\x12#\n" +
	"\rallowed_hosts\x18\r \x03(\tR\fallowedHosts\x12B\n" +
	"\x1essh_connect_for_publickey_port\x18\x0f \x01(\x05R\x1asshConnectForPublickeyPort\x12D\n" +
	"\ruser_profiles\x18\x10 \x03(\v2\x1f.ServerConfig.UserProfilesEntryR\fuserProfiles\x121\n" +
	"\x15host_signing_tls_path\x18\x11 \x01(\tR\x12hostSigningTlsPath\x124\n" +
	"\x16oidc_configuration_url\x18\x12 \x01(\tR\x14oidcConfigurationUrl\x12;\n" +
	"\x1blook_for_audience_in_app_id\x18\x13 \x01(\bR\x16lookForAudienceInAppId\x12C\n" +
	"\x1flook_for_hosted_domain_in_email\x18\x14 \x01(\bR\x1alookForHostedDomainInEmail\x12.\n" +
	"\x13skip_email_verified\x18\x15 \x01(\bR\x11skipEmailVerified\x1a(\n" +
	"\n" +
	"UserConfig\x12\x1a\n" +
	"\bprofiles\x18\x04 \x03(\tR\bprofiles\x1a\x8f\x02\n" +
	"\aProfile\x12\x1e\n" +
	"\n" +
	"principals\x18\x01 \x03(\tR\n" +
	"principals\x12U\n" +
	"\x10cert_permissions\x18\x02 \x03(\v2*.ServerConfig.Profile.CertPermissionsEntryR\x0fcertPermissions\x12(\n" +
	"\x10ssh_config_lines\x18\x03 \x03(\tR\x0esshConfigLines\x12\x1f\n" +
	"\vknown_hosts\x18\x04 \x03(\tR\n" +
	"knownHosts\x1aB\n" +
	"\x14CertPermissionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aY\n" +
	"\x11AllowedUsersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12.\n" +
	"\x05value\x18\x02 \x01(\v2\x18.ServerConfig.UserConfigR\x05value:\x028\x01\x1aV\n" +
	"\x11UserProfilesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12+\n" +
	"\x05value\x18\x02 \x01(\v2\x15.ServerConfig.ProfileR\x05value:\x028\x01*B\n" +
	"\fResponseCode\x12\x06\n" +
	"\x02OK\x10\x00\x12\x14\n" +
	"\x10INVALID_ID_TOKEN\x10\x01\x12\x14\n" +
	"\x10NO_CERTS_ALLOWED\x10\x022E\n" +
	"\rGeeCertServer\x124\n" +
	"\vGetSSHCerts\x12\x10.SSHCertsRequest\x1a\x11.SSHCertsResponse\"\x00B\x1fZ\x1dgithub.com/continusec/geecertb\x06proto3"

var (
	file_sso_proto_rawDescOnce sync.Once
	file_sso_proto_rawDescData []byte
)

func file_sso_proto_rawDescGZIP() []byte {
	file_sso_proto_rawDescOnce.Do(func() {
		file_sso_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_sso_proto_rawDesc), len(file_sso_proto_rawDesc)))
	})
	return file_sso_proto_rawDescData
}

var file_sso_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_sso_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_sso_proto_goTypes = []any{
	(ResponseCode)(0),               // 0: ResponseCode
	(*SSHCertsRequest)(nil),         // 1: SSHCertsRequest
	(*SSHCertsResponse)(nil),        // 2: SSHCertsResponse
	(*ServerConfig)(nil),            // 3: ServerConfig
	(*ServerConfig_UserConfig)(nil), // 4: ServerConfig.UserConfig
	(*ServerConfig_Profile)(nil),    // 5: ServerConfig.Profile
	nil,                             // 6: ServerConfig.AllowedUsersEntry
	nil,                             // 7: ServerConfig.UserProfilesEntry
	nil,                             // 8: ServerConfig.Profile.CertPermissionsEntry
}
var file_sso_proto_depIdxs = []int32{
	0, // 0: SSHCertsResponse.status:type_name -> ResponseCode
	6, // 1: ServerConfig.allowed_users:type_name -> ServerConfig.AllowedUsersEntry
	7, // 2: ServerConfig.user_profiles:type_name -> ServerConfig.UserProfilesEntry
	8, // 3: ServerConfig.Profile.cert_permissions:type_name -> ServerConfig.Profile.CertPermissionsEntry
	4, // 4: ServerConfig.AllowedUsersEntry.value:type_name -> ServerConfig.UserConfig
	5, // 5: ServerConfig.UserProfilesEntry.value:type_name -> ServerConfig.Profile
	1, // 6: GeeCertServer.GetSSHCerts:input_type -> SSHCertsRequest
	2, // 7: GeeCertServer.GetSSHCerts:output_type -> SSHCertsResponse
	7, // [7:8] is the sub-list for method output_type
	6, // [6:7] is the sub-list for method input_type
	6, // [6:6] is the sub-list for extension type_name
	6, // [6:6] is the sub-list for extension extendee
	0, // [0:6] is the sub-list for field type_name
}

func init() { file_sso_proto_init() }
func file_sso_proto_init() {
	if File_sso_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_sso_proto_rawDesc), len(file_sso_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_sso_proto_goTypes,
		DependencyIndexes: file_sso_proto_depIdxs,
		EnumInfos:         file_sso_proto_enumTypes,
		MessageInfos:      file_sso_proto_msgTypes,
	}.Build()
	File_sso_proto = out.File
	file_sso_proto_goTypes = nil
	file_sso_proto_depIdxs = nil
}
